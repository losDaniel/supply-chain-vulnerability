import os
from path import Path 
root = str(Path(os.path.abspath(os.path.dirname(__file__))).parent)

import supply_chain_mapping.data_cleaning_and_processing as dc

import pandas as pd
import numpy as np
import networkx as nx
import random


random.seed(1)


def get_networks(complete_data=None, directed=True, sample_p = 1):

    # Import the network data 
    graph_data = dc.get_network_data(complete_data=complete_data)
    
    # Create a dataset of origin attributes for each node 
    summ_cols = ['date_origin','duration'] + list(graph_data['status_origin'].unique())
    node_origin_attributes = pd.concat([graph_data, pd.get_dummies(graph_data['status_origin'])], 1)[['origin']+summ_cols].groupby('origin').mean()
    
    # Create a dataset of origin attributes for each node 
    summ_cols = ['date_destination'] + list(graph_data['status_destination'].unique())
    node_destination_attributes = pd.concat([graph_data, pd.get_dummies(graph_data['status_destination'])], 1)[['destination']+summ_cols].groupby('destination').mean()
    
    # Merge the origin and destination atrributes for each node 
    node_info = node_origin_attributes.merge(node_destination_attributes, right_index=True, left_index=True, indicator=True, suffixes=('_org','_dst'))
    

    # Take a sample of the data. Default is the full dataset  # clocked 1.46s 
    ids_to_use = random.sample(list(graph_data['Individual Identification  Number'].values), int(np.floor(len(graph_data)*sample_p)))
    graph_data_sample = graph_data[graph_data['Individual Identification  Number'].isin(ids_to_use)]
    
    # Collapse the network based on origin-destination connections to get the edges of the networks 
    graph_data_sample['weight'] = 1 
    edges = graph_data_sample.groupby(['origin','destination'],as_index=False)['weight'].sum()
    edges['weight'] = edges['weight']/edges['weight'].max()
    print('Weight distribution parameters:') 
    print(edges['weight'].describe())
    
    
    if directed: 
        Gn = nx.DiGraph() 
    else: 
        Gn = nx.Graph() 
    
    # Transpose the node-info 
    node_info_T = node_info.transpose()
    
    attr=node_info_T.index.values    
    
    for col in node_info_T.columns:
        attr_node=dict(list(zip(attr, node_info_T[col].values)))
        Gn.add_node(col,attr_dic=attr_node)
    
    # Read in the edges for the network 
    for tup in edges.itertuples():
        Gn.add_edge(tup.origin, tup.destination, weight=tup.weight)
        
    return Gn, edges, graph_data