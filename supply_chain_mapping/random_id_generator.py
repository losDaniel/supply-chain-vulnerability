# -*- coding: utf-8 -*-
"""
The gov issues and allocates ID numbers to specific farmers at the beginning 
of a fiscal year by estimating the number of ID tags each farmer will need in 
the year to reduce time lags between cattle birth and tag attachment.

Some ID beginning with “0” were assigned to cattle for model projects 
(proof-of-concept).

"""

import random
import itertools
import pandas as pd 
from supply_chain_mapping import supply_chain_data_scraper as scd


def get_random_id(lower_bound=10000000, upper_bound=100000000):
    '''# Generate a random ID based in the registrys rules'''
    randidbase = '1' + str(random.randint(lower_bound, upper_bound))
    randid = randidbase + str(get_last_digit(randidbase))
    return randid


def random_cowid_generator(batch_size=100, search_prefix=''):
    '''Generate a list of random cow IDs of size batch_size. These will be unique and not overlap with IDs in the collected folder'''
    # Get all the collected data
    collected_ids, failed_ids = scd.get_collected_ids(search_prefix=search_prefix)

    total_ids = list(set(collected_ids)) + list(set(failed_ids))

    # Create your batch        
    id_batch = []
    idbl = len(id_batch)
    
    # Until we've generated a batch of size batch_size 
    while idbl < batch_size: 
        # First create a list of ids of the desired length 
        while len(id_batch) < batch_size: 
            id_batch.append(get_random_id())
        # Remove repeated Ids by turning it into a set and compare the IDs to the list of existing collected IDs
        seta = set(id_batch)
        setb = set(total_ids)
        id_batch = seta.difference(setb)
        id_batch = list(id_batch)
        idbl = len(id_batch)        
        
    return id_batch


def bounded_random_ids(eligible_prefixes, n_chars, batch_size=100, lower_bound=10000000, upper_bound=100000000, search_prefix=''):
    '''Creat a set of random IDs that begin with the eligible prefixes submitted
    __________
    parameters:
        - eligible_prefixes : list of str. 
        - n_chars : int. number of characters in the ID that should  adhere to the prefixes. 
        - batch_size : int. Size of the batch of IDs 
        - lower_bound : int. Lower bound for generating random IDs, useful when eligible prefixes are consecutive
        - upper_bound : int. Upper bound for generating random IDs, useful when eligible prefixes are consecutive
        - search_prefix : str. The prefix of the files you want to use to search for existing ID files in the collected folder. 
    '''

    collected_ids, failed_ids = scd.get_collected_ids(search_prefix=search_prefix)

    total_ids = list(set(collected_ids)) + list(set(failed_ids))

    # Create your batch        
    id_batch = []
    idbl = len(id_batch)

    # Until we've generated a batch of size batch_size 
    while idbl < batch_size: 
        # First create a list of ids of the desired length 
        while len(id_batch) < batch_size:
            # We don't accept random IDs that don't fit the bounds
            random_id = get_random_id()
            while random_id[:n_chars] not in eligible_prefixes:
                random_id = get_random_id()
            id_batch.append(random_id)
        # Remove repeated Ids by turning it into a set and compare the IDs to the list of existing collected IDs
        seta = set(id_batch)
        setb = set(total_ids)
        id_batch = seta.difference(setb)
        id_batch = list(id_batch)
        idbl = len(id_batch)        
        
    return id_batch


# def realistic_random_ids(list_of_eligible_prefixes, search_prefix=''):
#     '''Creates a set of random IDs based on the first 5 digits of the IDs that have been collected (starting with "1" for active IDs) and every available set of the next four digits
#     __________
#     parameters:
#         - list_of_eligible prefixes : list of str of len = 2. The digits that random IDs can be launched with
#     '''

#     data = pd.read_csv('G:/My Drive/Supply Chain Vulnerability/supply-chain-vulnerability/data/collected/final'+search_prefix+'_collected_save.csv', dtype={'個体識別番号':'O','id0':'O','id1':'O','id2':'O'})

#     data['id0'] = data['個体識別番号'].astype(str).str[0:5]
#     data['id1'] = data['個体識別番号'].astype(str).str[5:9]

#     data['active_ids'] = data['個体識別番号'].astype(str).str[0:1]
#     data['active_ids'] = data['active_ids'].apply(lambda x: 1 if x in list_of_eligible_prefixes else 0)
#     active_data = data[data['active_ids']==1]

#     # Use the examples of the first and second parts of the IDs
#     unique_0_ids = list(active_data['id0'].unique())
#     unique_1_ids = list(active_data['id1'].unique())

#     # Create all pairwise combinations of these 
#     ID_combinations = list(itertools.product(unique_0_ids, unique_1_ids))
#     random_ids = [str(i[0])+str(i[1])+str(get_last_digit(str(i[0] + i[1]))) for i in ID_combinations]

#     setA = set(random_ids)
#     setB = set(list(data['個体識別番号'].values))

#     new_random_ids = setA.difference(setB)

#     return list(new_random_ids) 


def get_last_digit(ids: str):
    '''The last digit in the ID number for the cattle is calculated base don the first nine digits as a confirmation. We have replicated the formula used here'''
    odd_nums = []
    even_nums = [] 
    odd=True 
    for i in ids: 
        if odd: 
            odd_nums.append(int(i))
            odd=False
        else:
            even_nums.append(int(i))
            odd=True

    import numpy as np

    odd_sum = np.sum(np.array(odd_nums))
    even_sum = np.sum(np.array(even_nums))

    rem = ((odd_sum*3)+even_sum)%10
    last_digit = 10-rem

    if last_digit == 10: 
        last_digit=0

    return last_digit 

